\documentclass[a4paper,UKenglish]{lipics-v2018}
\usepackage{microtype}%if unwanted, comment out or use option "draft"
\bibliographystyle{plainurl}

\title{Formal Methods for Security - Final Report}

\author{Daniel Schaefer}{2549458}{}{}{}
\authorrunning{Daniel Schaefer}
\renewcommand{\copyrightline}{}

\def\murphi{Mur$\phi$ }

\begin{document}
\maketitle

\begin{abstract}
In this course we generally talked about various methods of model-checking security protocols. Later on here should be a text that summarizes the idea and findings of the seminar.\\
% TODO Extend

\includegraphics[scale = 0.72]{pictures/grading_scheme}\\
\end{abstract}


\newpage
\section{Model Checking Security Protocols}

This paper written by Basin et al. Outlines the difficulties of analyzing a security protocol in an automated fashion. The hardness of this particular problem specifically originates from the non-deterministic adversary, that is able to interact with arbitrary many protocol-executions that are being interleaved. Interaction with the executions in this case means, that the adversary is in control of the network that the protocol is executed on, which means that it can intercept, redirect and alter any data that is being sent.\cite{model_checking_security_protocols}

During et al. were able to proof that the secrecy problem is undecidable for such an attacker model if the number of protocol executions and random values (nonces) are unbounded.\cite{DLMS99} If one is able to keep the number of protocol executions bounded the secrecy problem was proven to be NP-complete by Rusinowitch and Turuani.\cite{RT01} This proof motivated development of model checkers in which the user explicitly specifies the number of protocol executions the model checker should search through which are in fact still useful in practice as most attacks on realistic protocols only require a few sessions.\cite{model_checking_security_protocols}

This attacker model is also called the Dolev-Yao attacker model. Many approaches of model checking cryptographic protocols adopted this attacker model and use it as part of an approach called 'Dolev-Yao symbolic model', which is explained in detail by Basin et al. in chapter 24.3 \cite{model_checking_security_protocols}.
% TODO: MAYBE: Pick important parts of definitions and list them here or a bit later maybe

In a symbolic model, messages are being represented by terms which formulate certain assumptions, essentially defining constraints on variables instead of arguing about concrete values. This measure is taken to counter the problem of state space explosion.\cite{model_checking_security_protocols}
% TODO: MAYBE: Define State space explosion?

% TODO: MAYBE: explain Notion of Secrecy and Weak Aliveness
% TODO: MAYBE: Forward vs Backwards Search?
% TODO: MAYBE: Link to computational soundness
% TODO: MAYBE: Non-Trace properties: e.g. non-interference, observational equivalence



\newpage
\section{Language Based Information Flow Security}

Sabelfeld at al. explain a promising new approach to guarantee that secret input data is not being 'leaked' to an attacker which observes the system output. This language-based technique, working on program semantics and analysis, relies on enforcing information-flow policies in source-code. Goal of these policies is to achieve properties like data confidentiality and noninterference.\cite{language_based_information_flow_security}

The approach, called "Information-flow control" is a mechanisms to enforce such policies. The analysis that is performed must then proof that no information flow exists, that would violate the previously specified policies.\cite{language_based_information_flow_security}

There are a significant number of channels one could leak information over, which are not directly transfering data. This is very obvious for the example of "termination channels" and "timing channels", which are related to an attackers ability to observe the behaviour of the program execution. This means that e.g. the duration of an computation or the non-termination of the program might leak information about secret values that were used as part of these computations.
The same applies to a number of additional channels, which are also not used to transfer data but still offer possible information leaks.\cite{language_based_information_flow_security} % TODO: List other Covert Channels

The focus in this paper is on a type checking approach to perform static information-flow analysis on compile time. Such a approach has already been implemented in the Jif compiler for Java.\cite{JFlow} The general idea is that a \textit{security type} is assigned to every program expression. This security type contains the ordinary type of the expression (such as int, float, string, etc.) and additionally a static label which describes how the resulting value can be used. This value is static and not determined on runtime, such that it can be used to verify the control flow on compile-time already.\cite{language_based_information_flow_security}
To be able to track implicit flows correctly, dependencies of the program-counter are additionally tracked.

The advantage of performing verification on compile time, compared to checking during runtime is that one is not limited to a single program execution, instead one can proof security of all possible program paths.\cite{language_based_information_flow_security}

% TODO: second half of this paper basically not contained in this summary
% TODO: Problems with this paper/approach



\newpage
\section{Secure Information flow by self-composition}

Type systems are a way to enforce secure information flow of a program but are hard to extend, which is particularly disadvantagous when additions have to be made to verify a new security policy. An alternative to these type systems is to use a more flexible approach of program logics, which this publication focuses on. Barthe et al. build on to the idea of self composition, which reduces the problem to a safety property of the composition of a program with itself.\cite{information_flow_by_self_composition}

Information flow properties are properties that correspond to at least two execution traces, instead of a safety property. Barthe et al. were able to proof that non-interference of some program p can be reduced to a property about every single program execution of a new program that can be constructed using P and P' (which is a renaming of P).\cite{information_flow_by_self_composition}
% TODO: paragraph above maybe to close to paper wording?

This knowledge can be used to apply (sound) programming logics to characterise non-interferance in an alternative way. The publication provides a theory to prove non-interferance using self-composition.

The definition of the indistinguishability relation determines wheather memories can be distinguished or not which makes this approach very flexible, as it allows a user to specify that some information can be 'leaked' without being a violation to our safety property.\cite{information_flow_by_self_composition}

A limitation of the approach that was presented in this paper, is the limitation to abstract values of variables\cite{information_flow_by_self_composition}, which means that one can not perform any operations on pointer-types. This implies that control-flow of a program can not depend on memory allocation. It remains to be seen if this limitation can be overcome by extending the presented approach or by translating these cases into an equivalent form using only abstract values.

% TODO: explain self-composition here more, how the Program is built from P and P'









\newpage
\section{Automated Analysis of Cryptographic Protocols using \murphi}

\murphi is a tool to analyze cryptographic protocols using a state enumeration approach. In a feasibility study it was able to outperform similar finite-state exploration tools on the protocols that were tested. Notable difference were the more efficient approach of \murphi to counteract the State-space explosion problem and the ability to set interrupt points to guide the search by hand, which can also be helpful to work around the State-space explosion problem.\cite{murphi}

\murphi performs explicit state enumeration using either breadth-first or depth-first search to proof that all reachable states satisfy some specification that is given by the user. The protocol has to be specified using the \murphi language, which can be extended to contain additional information for an attacker such as leaking some supposedly secret values initially which would reflect the assumption that part of the system was compromised already. Due to the fact that \murphi performs explicit state enumeration, one has to limit the number of states, which is done by fixing system size parameters, such as the number of agents that perform the cryptographic protocol with each other. These limitations have to be specifially set by the user and \murphi is only able to guarantee correctness of this "down-scaled" version of the protocol. Clearly it is not trivial to set these numbers, as larger values often have exponential effect on the runtime of the tool.\cite{murphi}

Performance of \murphi is significantly improved using a hash table which stores the reached states as this avoids recomputation when visiting the same state again in the future. The memory used by this hash table is typically a limitation of the \murphi tool.\cite{murphi}
% TODO: maybe list other features that significantly improve performance, quite a lot of them

Formulating a protocol in the \murphi language reveals some issues a user might have. It is important to simplify to protocol and only modeling the key steps and primitives that are necessary to perform the protocol. This is particularly important to reduce the number of states that are explicitly enumerated. Additionally it is essential to define precisely which messages will be accepted or declined by each participant of the protocol and also how these messages are formated, because \murphi uses shared variables to communicate. These shared variables are accessable by an attacker, which is part of the ability of a Dolev-Yao attacker (network under control of adversary).\cite{murphi}

Similar issues arise when formulating an adversary to a protocol. The user has to specify the entire knowledge of the adversary and a finite set of actions that the adversary could perform at any point in time depending on the knowledge the adversary has gathered until this point.\cite{murphi}

% TODO: IMPORTANT: explain when/how 'wrong' error traces occur and how one specifies protocol/attacker around these

% TODO: maybe list problems/results from modeling the protocols that are listed throughout the entire paper




\newpage
\section{SAT based model-checking for security protocol analysis}
% TODO:



\newpage
\section{Automatic Verification of Security Protocols in the Symbolic Model: the Verifier ProVerif}
Example citation \cite{ProVerif}
% TODO:



\bibliography{finalReport}


\end{document}